# **Руководство по использованию библиотеки `discord-py`**
### *Здесь вы можете почитать об основах, которые необходимо понимать, чтобы грамотно работать с библиотекой и не задавать вопросов, касающихся самых базовых вещей*
___

Вероятнее всего у вас уже имеется созданный бот, поэтому инструкция по его созданию будет пропущена *(но, возмжно появится позже)*.

## Прежде чем начать...

Прежде чем приступать к работе с ботом, я сразу рекомендую зайти на страницу вашего бота и включить **намерения** (`intents`, [**подробнее**][4]). Для этого зайдите в [раздел приложений][1] и выберите вашего бота. Затем, слева, на вкладке **`"Bot"`**

[![Бот][2]][2] 

Включите параметры `PRESENCE INTENT` и `SERVER MEMBERS INTENT`

[![введите сюда описание изображения][3]][3]

После этого выдайте намерения в коде при [**инициализации бота**][34]

Намерения нужны для работы с некоторыми событиями, объектами пользователей серверов (`участник`/`member`) и др. Они вам точно понадобятся, поэтому лучше включить их сразу, чтобы потом не спрашивать, почему вам не удается получить данные о пользователе сервера или чего-либо еще.

---

## Начало работы с ботом и `discord-py`

Бот, которого вы создали на странице [приложений][9], является аккаунтом дискорда, который по сути является таким же пользовательским аккаунтом, как и ваш, но с атрибутом `bot` и некоторыми ограничениями. Чтобы бот начал что-то делать, нужно создать его в коде и прописать логику.

Для начала рассмотрим виды ботов, которые предоставляет библиотека:

- [`discord.Client`][5] - фактически, самый базовый бот, на котором основаны другие. Умеет обрабатывать события по типу получения сообщений `on_message()`, установки реакции `on_raw_reaction_add()` и [другие][6].
- [`discord.ext.commands.Bot`][7] - тот же `discord.Client`, только умеет находить в сообщениях и обрабатывать отдельные команды, которые начинаются с какого-либо префикса, например `!test`
- [`discord.ext.commands.Cog`][8] - про этого бота ничего сказать не могу, так как ни разу не использовал. Насколько мне известно, он нужен в тех случаях, когда вы планируете задать боту кучу разных комманд, событий и организовать все это в один отдельный класс.

В общем-то, выбор бота зависит напрямую от цели использования. Если вам нужен простой бот, который будет читать чат, фильтровать мат и т.п., считывать реакции, выдавать роли при входе нового пользователя и т.д., то вам хватит базового бота [`discord.Client`][5].

Если помимо того, что я написал выше, вы хотите **добавить еще** и обработку команд по типу `!ban <@User>`, `!play <Ссылка на видео с YouTube>`, `!погода` и т.п., то использовать надо именно  [`discord.ext.commands.Bot`][7].

---

## Пишем код

Теперь, когда вы определились с ботом можно наконец-то приступить к написанию кода.

Для начала подключим библиотеку.
```py
import discord
```

**На данном этапе я настоятельно рекомендую ознакомиться с [руководством по использованию документации][10], так как на эту самую документацию я буду ссылаться очень часто и без ее использования вы вряд ли напишете что-то самостоятельно и будете постоянно спрашивать как реализовать ту или иную функцию.**

В случае, если вы хотите использовать [`discord.ext.commands.Bot`][7], я бы сразу отдельно добавил еще и этот класс
```py
from discord.ext import commands
```

### Инициализация бота

Теперь создадим объект бота, который будет обрабатывать события и команды:

Из [документации][7] видим, что единственным обязательным аргументом при создании экземпляра класса является `command_prefix`.

Он принимает строку (`str`), по которой бот будет определять, то что сообщение является командой и обрабатывать его нужно именно как команду.

Помимо этого, выдадим боту намерения (`intents`), инструкция по настройке которых была [в начале][11].

*В качестве префикса команды укажем `!`, намерения нужно выдавать именно те, которые вы будете использовать, но на первое время можно выдать все, то есть `discord.Intents.all()`*

**Если у вас `discord.ext.commands.Bot`:**
```py
bot = commands.Bot(command_prefix='!', intents=discord.Intents.all())
```
**Если у вас `discord.Client`, то префикс указывать не нужно (класс не принимает такого аргумента):**
```py
bot = discord.Client(intents=discord.Intents.all())
```

---

### Основные обработчики событий

Теперь у нас есть объект `bot`, для которого нужно написать логику взаимодействия. 

В качестве обработчиков событий используются асинхронные (`async`) функции (`def`), помеченные декоратором `@bot.event`, где `bot` - название объекта вашего бота. Функция должна иметь название, строго как в документации - иначе событие просто не будет обработано.

Если коротко, то все, что делает декоратор `@bot.event` - это помещает написанную вами функцию в другую функцию из библиотеки `discord`, которая, в свою очередь, передает вашей функции какие-либо параметры. Поэтому, если не пометить функцию декоратором, `discord` не обратит на нее внимание и она не будет вызвана.

#### `async def on_ready()`

Первым делом, нужно удостовериться, что бот успешно запустился и готов к работе. В [списке событий][6] находим событие [`on_ready()`][12], которое вызывается **один раз** при запуске кода и обозначает то, что бот загрузился и готов к работе. 

Здесь нужно отметить, что в этой функции не следует размещать фрагменты кода, которые должны будут выполняться в дальнейшем, так как функция будет вызвана только один раз.
Поэтому в этой функции можно разместить какое-либо сообщение, о том, что бот запущен и, если есть работа с данными из файлов, то самое время их подгрузить. *В общем, выполнить все единоразовые процедуры*.

**Выглядеть это будет вот так:**
```py
@bot.event
async def on_ready():
  # сам по себе объект bot (discord.ext.commands.Bot) не содержит имени бота
  # зато содержит объект пользователя, которым он является
  # а вот объект пользователя уже хранит в себе имя
  print(f'{bot.user.name} запустился и готов к работе!')
```

#### `async def on_message(message)`

Добавим обработчик сообщений, чтобы получать вызов функции каждый раз, когда `bot` получает сообщение в ЛС или на сервере. 

В [списке событий][6] находим событие [`on_message(message)`][13], которое принимает обязательный аргумент `message`. Этот аргумент имеет тип `discord.Message` из которого вы можете получить текст сообщения, а также объекты автора сообщения, сервер, канал, вложения, реакции, упоминания, ссылку на сообщение и [много чего еще][14]

```py
@bot.event
async def on_message(message):
  print(f'Получено сообщение! Текст: {message.content}, Сервер: {message.guild}')
```

Здесь вы можете прописать любую логику взаимодействия. Хоть даже удалять все только что переданные обработчиком сообщения *(главное чтобы у бота были на то права)*.
Самое главное - задать функции аргумент, который будет принимать объект сообщения. Вы можете назвать его как хотите, например даже так: `async def on_message(soobshenie)`, главное чтобы он был.

Если аргумент не указать, то при вызове события нового сообщения, `discord-py` отправит в функцию `on_message()` аргумент, содержащий объект сообщения, но получит ошибку о том, что указанная функция не принимает аргументов и ничего работать не будет. Это равноценно созданию функции, которая должна считать сумму 2 переданных в виде аргументов числа, но при этом она не принимает их.

---

#### Другие события

По аналогии с примерами, приведенными выше, можно создать обработчик любого другого события, предствленного в `discord-py`. Главное, чтобы совпадало название и принимаемые аргументы. 

Примеры других часто используемых событий:

[`on_raw_reaction_add(payload)`][15], [`on_raw_reaction_remove(payload)`][16] - события добавления и удаления реакции с сообщения, соответствено. Из объекта [`payload`][17] вы можете получить сервер, сообщения и [прочую инфу][17]

[`on_member_join(member)`][18], [`on_member_remove(member)`][18] - события подключения и выхода участника с сервера, в качестве аргумента принимает объект участника из которого можно получить всю информацию о пользователе.

Остальное вы можете найти в [списке событий][6].

---

### Запуск бота

У вас уже есть объект бота и, вероятно, обработчики событий. Теперь бота нужно запустить.

При помощи токена, который нужно скопировать на странице бота, в [разделе приложений][1] вы можете авторизоваться в аккаунте бота.

Для этого у объекта `bot` нужно вызвать функцию [`run()`][19]:
```py
TOKEN = '' # здесь ваш токен
bot.run(TOKEN)
```

#### Особенности

Данная строка должна всегда находиться в самом низу кода. После ее выполнения бот будет запущен и весь код, который находится ниже этой строки будет выполнен только после завершения работы бота.

Бот будет выполнять работу до дех пор, пока вы не завершите выполнение кода. Это означает, что если вы закроете консольное окно программы, то бот перестанет работать и обрабатывать какие-либо события.

Чтобы бот работал без вашего участия, его можно поставить на хостинг - тогда он будет постоянно запущен на удаленном сервере, а не на вашем устройстве. Например, можно использовать бесплатный хостинг [**Heroku**][32]. В интернете есть куча разных туториалов по настройке. *Возможно, когда-нибудь здесь появится ссылка на мой :)*

---

В итоге должен получиться примерно такой код, посмотреть который можно [**здесь**][20].

Данный бот выводит сообщение при успешном запуске, а также подробную информацию о каждом полученном сообщении.

Для этого примера достаточно было бы простого бота [`discord.Client`][5], так как он обрабатывает только события. Но я наперед прописал в коде бота [`discord.ext.commands.Bot`][7], так как дальше в этот код мы будем добавлять обработку команд.

---

### Обработка отдельных команд

*Напоминаю, что для работы с командами, в качестве бота нужно использовать объект [`discord.ext.commands.Bot`][7], а не [`discord.Client`][5]! Не забудьте также про [**префикс**][30]*

 - Команды бота, как и обработчики событий, являются асинхронными функциями (`async def`). 

 - Чтобы `discord-py` обнаружил команду в коде, функцию нужно пометить декоратором `@bot.command()`, где `bot` - название объекта вашего бота.
   
   **Скобки в декораторе `@bot.command()` обязательны**, в отличии от `@bot.event`, так как декторатор [`discord.ext.commands.Command()`][22] принимает необязательные аргументы.    Без скобок декоратор корректно работать не будет. **Подробнее про декораторы можно почитать [**выше**][21]*

 - В отличии от обработчиков событий, функцию можно назвать как захочется - **название функции станет названием команды**.

 - **Любая** функция, являющаяся командой, должна принимать обязательный аргумент `ctx` *(можно назвать как угодно)*. Аргумент является контекстом ([`discord.ext.commands.Context`][22]) выполнения команды, из которого можно получить сервер, автора, сообщение, канал и др. информацию. При вызове команды, Контекст в функцию передает библиотека `discord-py`.

#### Перед созданием первой команды

Для начала, если у вас в коде есть обработчик событий [`on_message()`][24], его нужно немного доработать.

Из документации видим, что у объекта пользователя ([`discord.User`][25]) есть свойство `bot`, имеющее тип `bool`. Значит, если свойство имеет значение `True` - пользователь является ботом, иначе - не является)

Допишем условие, чтобы сообщения от любых ботов *(включая нашего)* игнорировались. Это часто делается для того, чтобы другие боты не могли спамить вызовами команд, обработка которых сначала проходит через `on_message()`, ведь любая команда в дискорде по сути является просто сообщением.

Для этого, кстати, в `on_message()` нужно добавить еще одну строку [`await bot.process_commands(message)`][26], которую можно найти в списке методов объекта [`discord.ext.commands.Bot`][7]. Метод принимает в качестве аргумента сообщение с типом `discord.Message` и нужен для того, чтобы проверять, являестя ли сообщение командой.
*Многие, забыв добавить эту строку, потом не понимают, почему их бот игнорирует команды ([**подробный разбор проблемы**][27])*
```py
@bot.event
async def on_message(message):
  if message.author.bot:
    return
  await bot.process_commands(message)
```
Ключевое слово `return` завершает выполнение функции, то есть код, который идет дальше, так или иначе не будет выполнен.

#### Создание первой команды

Создадим команду с названием `test`, при вызове которой бот будет отвечать в чат *"Успешный тест!"*:
```py
@bot.command()
async def test(ctx):
  # список свойств и методов контекста можно найти в документации по запросу context
  await ctx.send('Успешный тест!')
```

**Результат:**

![image](https://user-images.githubusercontent.com/61795655/145378119-85a817ce-2deb-4e62-af39-7a586d1dbee8.png)

Все работает!

Реализацию такой команды можно было бы сделать через обычного бота [`discord.Client`][5] прямо в `on_message()`, проверяя, наличие префикса и конкретного названия команды. Однако при большом количестве команд запихивать все в одну функцию не очень хорошо, да и не удобно разделять аргументы, про которые, кстати, можно почитать далее.

*\*Почитать подробнее, почему не стоит делать команды через `on_message()` можно [**здесь**][28]*

#### Сложные команды

##### Несколько названий

Для создания нескольких названий одной команды можно передать в декоратор `@bot.command()` аргумент [`aliases`][29], принимающий список (`list`) или кортеж (`tuple`) с названиями команды. При этом самого названия функции там быть **не должно**.
```py
@bot.command(aliases=['test', 'тест', 'тестовая_команда', 'test_command'])
async def test_(ctx):
  pass
```

##### Работа с аргументами команды

Предположим, вам нужно при вызове функции принять от пользователя `число`, `значение типа bool` и участника сервера `discord.Member`

![image](https://user-images.githubusercontent.com/61795655/145395100-3c4edf01-181a-4b93-a849-b99969298da2.png)

Чтобы принять эти параматры, нужно указать их в качестве аргументов функции, которая используется в качестве команды:
```py
@bot.command()
async def get_values(ctx, number, boolean, member):
    ...
```

Поскольку `Python` - язык с динамической типизацией, по умолчанию все полученные значения принимают строковый тип `str`, так как фактически были получены из строки (`str`), содержащей текст сообщения. 

**Тогда**

 - `number` будет равно `'16'`
 - `boolean` будет равно `'True'`
 - `member` будет равно `'<@!239863351063144451>'`
      
*То есть из `number` нельзя будет вычесть число, `boolean == True` примет значение `False`, а `member` просто примет строку, содержащую форму упоминания пользователя.*

Вместо того, чтобы вручную выполнять приведение типов *(`number = int(number)`, `boolean = bool(boolean)` и т.д.)*, можно сразу же явно указать тип аргумента функции:
```py
@bot.command()
async def get_values(ctx, number: int, boolean: bool, member: discord.Member):
    ...
```
И вот теперь уже все будет работать корректно. Помимо [`discord.Member`][31] можно указать любой другой тип библиотеки `discord-py`.

Из объекта `member`, например, можно получить `id` (`member.id`), ссылку на аватар (`member.avatar_url`) и [другую информацию][31], которую можно найти в документации по объекту [`discord.Member`][31].  
      
##### Получить весь текст как один аргумент

В случае, когда вам в качестве аргумента нужен весь текст команды, можно использовать оператор `*`:

![image](https://user-images.githubusercontent.com/61795655/145401040-35bea371-2462-43b5-83ce-79f29968ecb1.png)

```py
@bot.command()
async def get_text(ctx, *, text):
    ...
```
`text` будет иметь тип `str` и значение `'это тестовый текст для проверки функции'`

---

Если сделать так:
```py
@bot.command()
async def get_text(ctx, *text):
    ...
```
`text` будет иметь тип `tuple` и значение `('это', 'тестовый', 'текст', 'для, 'проверки', 'функции')`

---

Также можно сначала получить несколько отдельных слов, а уже потом оставшийся текст:
```py
@bot.command()
async def get_text(ctx, first_word, second_word, *, other_text):
    ...
```

 - `first_word` будет иметь тип `str` и значение `'это'`
 - `second_word` будет иметь тип `str` и значение `'тестовый'`
 - `other_text` будет иметь тип `str` и значение `'текст для проверки функции'`
 
 ---
 
 ## Итог
 
 Если смешать все команды из руководства в один код, то должно получиться что-то [**такое**][33].
 
 Данной информации должно хватить для понимания базовых вещей, таких как **работа с документацией**, **создание команд**, **работа с обработчиками событий** и т.д.
 
 На основе этого, имея навыки программирования, можно создать любого бота, ограничиваясь только своей фантазией *(ну и функционалом библиотеки `discord-py` xD)*.
 
 
[1]: https://discord.com/developers/applications
[2]: https://i.stack.imgur.com/ZnOYm.png
[3]: https://i.stack.imgur.com/HZCQP.png
[4]: https://discordpy.readthedocs.io/en/stable/intents.html
[5]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=client#discord.Client
[6]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=event#discord-api-events
[7]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=bot#discord.ext.commands.Bot
[8]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=cog#discord.ext.commands.Cog
[9]: https://discord.com/developers/applications
[10]: https://github.com/denisnumb/discord-py-guide/blob/main/using_docs.md#%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8-discord-py
[11]: https://github.com/denisnumb/discord-py-guide/blob/main/discord-py.md#%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5-%D1%87%D0%B5%D0%BC-%D0%BD%D0%B0%D1%87%D0%B0%D1%82%D1%8C
[12]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=event#discord.on_ready
[13]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=event#discord.on_message
[14]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=event#discord.Message
[15]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=on_raw_reaction_add#discord.on_raw_reaction_add
[16]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=on_raw_reaction_add#discord.on_raw_reaction_remove
[17]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=on_raw_reaction_add#discord.RawReactionActionEvent
[18]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=on_raw_reaction_add#discord.on_member_join
[19]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=bot#discord.ext.commands.Bot.run
[20]: https://github.com/denisnumb/discord-py-guide/blob/main/examples/events.py
[21]: https://github.com/denisnumb/discord-py-guide/blob/main/discord-py.md#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9
[22]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=command#command
[23]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=context#discord.ext.commands.Context
[24]: https://github.com/denisnumb/discord-py-guide/blob/main/discord-py.md#async-def-on_messagemessage
[25]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=message#discord.User
[26]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=bot#discord.ext.commands.Bot.process_commands
[27]: https://github.com/denisnumb/discord-py-guide/blob/main/problems/%D0%B1%D0%BE%D1%82%20%D0%B8%D0%B3%D0%BD%D0%BE%D1%80%D0%B8%D1%80%D1%83%D0%B5%D1%82%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B.md
[28]: https://github.com/denisnumb/discord-py-guide/blob/main/problems/%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20on_message.md
[29]: https://discordpy.readthedocs.io/en/stable/ext/commands/api.html?highlight=bot#discord.ext.commands.Command.aliases
[30]: https://github.com/denisnumb/discord-py-guide/blob/main/discord-py.md#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B1%D0%BE%D1%82%D0%B0
[31]: https://discordpy.readthedocs.io/en/stable/api.html?highlight=member#discord.Member
[32]: https://www.heroku.com/
[33]: https://github.com/denisnumb/discord-py-guide/blob/main/examples/commands.py
[34]: https://github.com/denisnumb/discord-py-guide/blob/main/discord-py.md#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B1%D0%BE%D1%82%D0%B0

